<html lang="en">

<head>
    <meta charset="utf-8">
    <title>PANAS-GEN Windrose + History</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        :root {
            --pad: 18px
        }

        body {
            font-family: system-ui, Arial, sans-serif;
            margin: 0;
            padding: var(--pad);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--pad)
        }

        h2 {
            margin: .2rem 0 .6rem
        }

        #left,
        #right {
            min-width: 320px
        }

        svg {
            width: 100%;
            height: 620px
        }

        svg#timeseries {
            height: 310px
        }

        .grid circle {
            fill: none;
            stroke: #eee
        }

        .axis line {
            stroke: #ccc
        }

        .label {
            font-size: 11px;
            text-anchor: middle
        }

        .handle {
            fill: #1f77b4;
            cursor: pointer
        }

        .current {
            fill: rgba(31, 119, 180, .25);
            stroke: #1f77b4;
            stroke-width: 2
        }

        .reference {
            fill: none;
            stroke: #888;
            stroke-width: 2;
            stroke-dasharray: 6, 6
        }

        .preview {
            fill: rgba(128, 0, 128, .12);
            stroke: purple;
            stroke-width: 2;
            stroke-dasharray: 4, 6
        }

        .monthly {
            fill: rgba(0, 128, 0, .10);
            stroke: green;
            stroke-width: 2;
            stroke-dasharray: 6, 4
        }

        .controls {
            display: flex;
            gap: .5rem;
            flex-wrap: wrap;
            margin-top: .5rem
        }

        button {
            padding: .5rem .8rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fff;
            cursor: pointer
        }

        button:hover {
            background: #f5f5f5
        }

        #status {
            font-size: .9rem;
            color: #666;
            margin-top: .4rem
        }

        .legend {
            display: flex;
            gap: 12px;
            align-items: center;
            margin: .3rem 0 .8rem
        }

        .sw {
            display: inline-block;
            width: 16px;
            height: 10px;
            border-radius: 2px
        }

        .sw.pos {
            background: #ffdc28
        }

        .sw.neg {
            background: #7832a0
        }

        .sw.extraversion {
            background: #ff7f0e
        }

        .sw.agreeableness {
            background: #2ca02c
        }

        .sw.conscientiousness {
            background: #9467bd
        }

        .sw.neuroticism {
            background: #8c564b
        }

        .sw.openness {
            background: #e377c2
        }

        textarea {
            width: 100%;
            height: 80px;
            margin-top: .6rem;
            padding: .4rem;
            font-family: inherit;
            font-size: 14px
        }

        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0, 0, 0, .75);
            color: #fff;
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 4px;
            white-space: pre-wrap;
            max-width: 360px;
            line-height: 1.35
        }

        .import-box {
            margin: .6rem 0;
            padding: 14px;
            border: 2px dashed #bbb;
            border-radius: 10px;
            text-align: center;
            font-size: .95rem;
            color: #555;
            user-select: none;
            cursor: pointer
        }

        .import-box strong {
            display: block;
            margin-bottom: .25rem
        }

        .import-box.hover {
            background: #fafafa;
            border-color: #888
        }

        .import-help {
            font-size: .85rem;
            color: #777;
            margin-top: .25rem
        }

        .row {
            display: grid;
            grid-template-columns: 1fr;
            gap: .6rem
        }

        .settings-toggle {
            margin-bottom: .5rem;
        }

        .settings-toggle button {
            font-size: 12px;
            padding: .4rem .6rem;
        }

        .settings-box {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            background: #f9f9f9;
            margin-bottom: 1rem;
            display: none;
        }

        .settings-box.expanded {
            display: block;
        }

        .settings-box label {
            display: block;
            margin-top: .8rem;
            font-weight: 600;
            font-size: 13px;
        }

        .settings-box input {
            width: 100%;
            padding: .5rem;
            margin-top: .3rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        .settings-box button {
            margin-top: .8rem;
        }


        /* ---- Intent Calibration section ---- */
        #intent-section {
            border-top: 2px solid #eee;
            padding-top: 1rem;
            margin-top: .8rem;
        }

        .sleep-row {
            display: flex;
            align-items: center;
            gap: .5rem;
            margin-top: .4rem;
        }

        .sleep-row label {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
        }

        .sleep-row button {
            padding: .3rem .7rem;
            border: 1px solid #bbb;
            border-radius: 4px;
            background: #f0f0f0;
            font-size: 12px;
            cursor: pointer;
            font-family: inherit;
        }

        .sleep-row button:hover {
            background: #e4e4e4;
        }

        .sleep-row input[type="number"] {
            width: 70px;
            padding: .3rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
        }

        #last-entry-date {
            font-size: 11px;
            color: #888;
            margin-left: auto;
        }

        #last-entry-date .fresh {
            color: #2a7;
        }

        #last-entry-date .stale {
            color: #c63;
        }

        #intent-section h2 {
            margin: 0 0 .8rem;
        }

        .intent-form {
            display: grid;
            gap: .55rem;
            max-width: 640px;
        }

        .intent-field label {
            display: block;
            font-weight: 600;
            font-size: 13px;
            margin-bottom: .15rem;
        }

        .intent-field textarea,
        .intent-field input[type="text"] {
            width: 100%;
            padding: .4rem;
            font-family: inherit;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .intent-field--inline {
            display: flex;
            align-items: center;
            gap: .5rem;
        }

        .intent-field--inline label {
            margin: 0;
            white-space: nowrap;
        }

        .intent-field--inline input[type="number"] {
            width: 80px;
            padding: .35rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
        }

        .intent-actions {
            display: flex;
            align-items: center;
            gap: .6rem;
            margin-top: .2rem;
        }

        .intent-status {
            font-size: 12px;
            color: #666;
        }

        /* notification / warning banners */
        .intent-note {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: .7rem 1rem;
            margin-bottom: .7rem;
            font-size: 14px;
        }

        .intent-drift {
            background: #f0f0f0;
            border-left: 3px solid #999;
            padding: .55rem 1rem;
            margin-bottom: .7rem;
            font-size: 13px;
        }

        .intent-collapse {
            border-left: 3px solid #d9534f;
            padding: .55rem 1rem;
            margin-bottom: .7rem;
            font-size: 13px;
            background: #fff0f0;
        }

        /* last intent display */
        .intent-last {
            background: #f4f0fa;
            border: 1px solid #d5cce8;
            border-radius: 8px;
            padding: .6rem .8rem;
            margin-bottom: .6rem;
            font-size: 13px;
            color: #444;
        }

        .intent-last strong {
            font-size: 11px;
            text-transform: uppercase;
            color: #7a5ea8;
            letter-spacing: .4px;
        }

        .intent-last .il-text {
            margin-top: .25rem;
        }

        .intent-last .il-meta {
            font-size: 11px;
            color: #999;
            margin-top: .2rem;
        }

        /* gentle pulse when check-in is due */
        @keyframes intent-pulse {

            0%,
            100% {
                border-color: #eee
            }

            50% {
                border-color: #ffc107
            }
        }

        #intent-section.intent-highlight {
            animation: intent-pulse 2s ease-in-out 3;
        }

        /* ---- Attribute selection on windrose ---- */
        .wedge-selected {
            stroke: #333;
            stroke-width: 2.5;
            cursor: pointer;
        }

        .wedge-hover {
            opacity: .85;
            cursor: pointer;
        }

        .attr-chips {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
            min-height: 22px;
        }

        .attr-chip {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, .15);
            user-select: none;
        }

        .attr-chip:hover {
            opacity: .8;
        }

        .attr-chip .chip-x {
            font-size: 13px;
            margin-left: 2px;
            opacity: .5;
        }

        .attr-chip .chip-x:hover {
            opacity: 1;
        }

        #ts-heading {
            margin: .2rem 0 .3rem;
        }
    </style>
</head>

<body>
    <div id="left">
        <h2>PANAS-GEN Windrose (drag petals)</h2>

        <div class="row">
            <div class="settings-toggle">
                <button id="toggleSettings">⚙️ Cloud Sync Settings</button>
            </div>
            <div class="settings-box" id="settingsBox"></div>
        </div>
        <div class="row">
            <div id="importBox" class="import-box" tabindex="0">
                <strong>Import database (.sqlite)</strong>
                Drop file here or click to choose
                <div class="import-help">Replaces the in-browser database; UI refreshes from the newest entry.</div>
                <input id="fileInput" type="file" accept=".sqlite,application/x-sqlite3,application/octet-stream"
                    style="display:none">
            </div>
        </div>

        <svg id="radar" viewBox="0,0,620,620"></svg>
        <label for="log">Log:</label>
        <textarea id="log" placeholder="Log..."></textarea>
        <div class="sleep-row">
            <label for="hours-slept">Sleep (h):</label>
            <input type="number" id="hours-slept" step="0.5" min="0" max="24" placeholder="7.5">
            <button id="save-sleep" title="Log sleep separately">Log Sleep</button>
            <span id="last-entry-date"></span>
        </div>

        <div class="controls">
            <button id="randomize">Randomize petals</button>
            <button id="save">Save + Download DB</button>
            <button id="copyJson">Copy JSON</button>
            <button id="clear">Clear DB</button>
        </div>

        <div id="status">30-day average (33 entries)</div>
        <div style="margin-top:.4rem;font-size:11px;color:#999">
            <a href="https://github.com/rlhjansen/minimal_mood_dashboard" target="_blank" style="color:#888">rlhjansen/minimal_mood_dashboard</a>
            &nbsp;·&nbsp; <span style="color:#c90">Subject to change — fork for a stable copy</span>
        </div>
    </div>

    <div id="right">
        <h2 id="ts-heading">Scores Over Time</h2>
        <div class="legend" id="ts-legend">
            <span
                style="display:inline-block;width:80px;height:12px;border-radius:2px;background:linear-gradient(to right, #7832a0, #a0a0a0, #ffdc28);vertical-align:middle"></span>
            <span style="font-size:11px">Neg ← Color → Pos</span> &nbsp;|&nbsp; Height = Balance, Saturation = Intensity
        </div>
        <div class="attr-chips" id="attr-chips"></div>
        <svg id="timeseries" viewBox="0,0,760,310"></svg>

        <div id="intent-anchor"></div>

    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/sql-wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Toggle settings visibility (outside async block so it works even if WASM loading stalls)
        document.getElementById("toggleSettings").onclick = () => {
            document.getElementById("settingsBox").classList.toggle("expanded");
        };
    </script>
    <script>
        (async function () {
            // --- PANAS items
            const ITEMS = ["Interested", "Distressed", "Excited", "Upset", "Strong", "Guilty", "Scared", "Hostile", "Enthusiastic", "Proud", "Irritable", "Alert", "Ashamed", "Inspired", "Nervous", "Determined", "Attentive", "Jittery", "Active", "Afraid"];
            const POS_IDX = [1, 3, 5, 9, 10, 12, 14, 16, 17, 19];
            const NEG_IDX = [2, 4, 6, 7, 8, 11, 13, 15, 18, 20];
            // Create sets for quick lookup (convert to 0-based)
            const POS_ITEMS = new Set(POS_IDX.map(i => ITEMS[i - 1]));
            const NEG_ITEMS = new Set(NEG_IDX.map(i => ITEMS[i - 1]));



            // --- SQLite init
            const SQL = await initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/${f}` });
            const LSKEY = "panas_db";
            function base64ToU8(b64) { if (!b64) return new Uint8Array(); const s = atob(b64); const u = new Uint8Array(s.length); for (let i = 0; i < s.length; i++)u[i] = s.charCodeAt(i); return u; }
            function u8ToBase64(u8) { let s = ""; u8.forEach(b => s += String.fromCharCode(b)); return btoa(s); }
            function persist() {
                localStorage.setItem(LSKEY, u8ToBase64(db.export()));
                /* Non-blocking cloud push if sync is active */
                if (window.PanasSync && window.PanasSync.isReady()) {
                    window.PanasSync.pushToCloud(function () { return db.export(); });
                }
            }


            let dbBytes = base64ToU8(localStorage.getItem(LSKEY) || "");
            let db = dbBytes.length ? new SQL.Database(dbBytes) : new SQL.Database();

            // base schema
            db.exec(`CREATE TABLE IF NOT EXISTS entries (id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT)`);
            const ensureCol = (name, type) => {
                const info = db.exec(`PRAGMA table_info(entries)`)[0]?.values || [];
                const names = info.map(r => r[1]);
                if (!names.includes(name)) { db.exec(`ALTER TABLE entries ADD COLUMN "${name}" ${type}`); }
            };
            ensureCol("log", "TEXT");
            ITEMS.forEach(it => ensureCol(it, "INTEGER NOT NULL DEFAULT 3"));
            ensureCol("positive_score", "INTEGER");
            ensureCol("negative_score", "INTEGER");
            ensureCol("hours_slept", "REAL");
            db.exec(`CREATE TABLE IF NOT EXISTS sleep_log (id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT, hours_slept REAL)`);
            db.exec(`UPDATE entries SET log='' WHERE log IS NULL`);
            persist();



            // --- Import (.sqlite)
            const importBox = document.getElementById("importBox");
            const fileInput = document.getElementById("fileInput");
            const status = t => document.getElementById("status").textContent = t;
            const setHover = on => importBox.classList.toggle("hover", !!on);

            ["dragenter", "dragover"].forEach(ev => {
                importBox.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); setHover(true); });
            });
            ["dragleave", "dragend", "drop"].forEach(ev => {
                importBox.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); if (ev !== "drop") setHover(false); });
            });
            importBox.addEventListener("click", () => fileInput.click());
            importBox.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); fileInput.click(); } });

            importBox.addEventListener("drop", (e) => {
                setHover(false);
                const f = e.dataTransfer.files?.[0];
                if (f) importDbFromFile(f);
            });
            fileInput.addEventListener("change", () => {
                const f = fileInput.files?.[0];
                if (f) importDbFromFile(f);
                fileInput.value = "";
            });

            async function importDbFromFile(file) {
                try {
                    status(`Importing "${file.name}"...`);
                    const buf = await file.arrayBuffer();
                    const u8 = new Uint8Array(buf);
                    const tmp = new SQL.Database(u8);
                    const needCols = () => {
                        const info = tmp.exec(`PRAGMA table_info(entries)`)[0]?.values || [];
                        const names = new Set(info.map(r => r[1]));
                        if (!names.has("log")) tmp.exec(`ALTER TABLE entries ADD COLUMN "log" TEXT`);
                        ITEMS.forEach(it => { if (!names.has(it)) tmp.exec(`ALTER TABLE entries ADD COLUMN "${it}" INTEGER NOT NULL DEFAULT 3`); });
                        if (!names.has("positive_score")) tmp.exec(`ALTER TABLE entries ADD COLUMN "positive_score" INTEGER`);
                        if (!names.has("negative_score")) tmp.exec(`ALTER TABLE entries ADD COLUMN "negative_score" INTEGER`);
                    };
                    needCols();
                    db = tmp;
                    persist();
                    refreshFromDb();
                    status(`Imported ${file.name} and refreshed from latest entry.`);
                } catch (err) {
                    console.error(err);
                    status("Import failed: not a valid PANAS SQLite file?");
                    alert("Import failed. Ensure you're selecting the exported panas.sqlite file.");
                }
            }

            // Helpers to read latest entry and refresh UI
            function getMostRecentEntry() {
                const res = db.exec(`SELECT ${ITEMS.map(n => `"${n}"`).join(",")} FROM entries ORDER BY id DESC LIMIT 1`);
                if (!res.length) return null;
                const row = res[0].values[0];
                const o = {}; ITEMS.forEach((n, i) => o[n] = row[i]);
                return o;
            }

            // --- Windrose setup
            const size = 620, radius = size / 2 - 70, levels = 5;
            // Clear any existing content from saved HTML
            d3.select("#radar").selectAll("*").remove();
            const svg = d3.select("#radar").attr("viewBox", [0, 0, size, size]).append("g").attr("transform", `translate(${size / 2},${size / 2})`);
            let labels = d3.shuffle(ITEMS.slice());
            let values = {};

            const last = getMostRecentEntry();
            ITEMS.forEach(l => values[l] = last ? (last[l] ?? 3) : 3);

            const step = radius / levels;
            const angleForIndex = i => (i / labels.length) * 2 * Math.PI;
            const posOnSpoke = (angle, v) => [Math.cos(angle) * (v * step), Math.sin(angle) * (v * step)];

            for (let l = 1; l <= levels; l++) { svg.append("circle").attr("r", l * step).attr("class", "grid"); }

            // Wedge background group (inserted before axes so axes draw on top)
            const wedgeGroup = svg.append("g").attr("class", "wedges");

            // --- Attribute selection state ---
            const selectedAttributes = new Set();
            // 10 distinct hues for up to 10 simultaneous selections
            const ATTR_PALETTE = [
                "#e6194b", "#3cb44b", "#4363d8", "#f58231", "#911eb4",
                "#42d4f4", "#f032e6", "#bfef45", "#fabebe", "#469990"
            ];
            let attrColorMap = {};  // label → color
            function assignAttrColors() {
                attrColorMap = {};
                let i = 0;
                selectedAttributes.forEach(label => { attrColorMap[label] = ATTR_PALETTE[i++ % ATTR_PALETTE.length]; });
            }

            function toggleAttribute(label) {
                if (selectedAttributes.has(label)) {
                    selectedAttributes.delete(label);
                } else {
                    selectedAttributes.add(label);
                }
                assignAttrColors();
                drawWedges();
                updateAttrChips();
                drawTimeSeries();
            }

            function updateAttrChips() {
                const container = document.getElementById('attr-chips');
                if (!container) return;
                const heading = document.getElementById('ts-heading');
                const legend = document.getElementById('ts-legend');
                if (!selectedAttributes.size) {
                    container.innerHTML = '';
                    if (heading) heading.textContent = 'Scores Over Time';
                    if (legend) legend.style.display = '';
                    return;
                }
                if (heading) heading.textContent = 'Attribute Scores Over Time';
                if (legend) legend.style.display = 'none';
                container.innerHTML = Array.from(selectedAttributes).map(label => {
                    const color = attrColorMap[label] || '#999';
                    return '<span class="attr-chip" style="background:' + color + '22;color:' + color + ';border-color:' + color + '55" data-attr="' + label + '">' +
                        label + '<span class="chip-x">&times;</span></span>';
                }).join('') +
                    '<span class="attr-chip" style="background:#f5f5f5;color:#666;border-color:#ccc" id="clear-all-attrs">Clear all</span>';
                container.querySelectorAll('.attr-chip[data-attr]').forEach(el => {
                    el.onclick = () => toggleAttribute(el.dataset.attr);
                });
                const clearBtn = document.getElementById('clear-all-attrs');
                if (clearBtn) clearBtn.onclick = () => {
                    selectedAttributes.clear();
                    assignAttrColors();
                    drawWedges();
                    updateAttrChips();
                    drawTimeSeries();
                };
            }

            // Helper to create arc path for a wedge
            function wedgePath(startAngle, endAngle, innerRadius, outerRadius) {
                const arc = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(outerRadius)
                    .startAngle(startAngle)
                    .endAngle(endAngle);
                return arc();
            }

            // Get wedge color based on item type (pos/neg) and value
            function getWedgeColor(label, value) {
                const isPositive = POS_ITEMS.has(label);
                // Saturation: value 1→5 maps to 0→1
                const sat = (value - 1) / 4;
                const baseColor = isPositive ? d3.rgb(255, 220, 40) : d3.rgb(120, 50, 160); // bright yellow / deep purple
                const gray = d3.rgb(240, 240, 240); // light gray base
                return d3.interpolateRgb(gray, baseColor)(sat);
            }

            function drawWedges() {
                wedgeGroup.selectAll("path").remove();
                const n = labels.length;
                const wedgeAngle = (2 * Math.PI) / n;
                labels.forEach((label, i) => {
                    const startAngle = angleForIndex(i) - wedgeAngle / 2 + Math.PI / 2;
                    const endAngle = startAngle + wedgeAngle;
                    const val = values[label];
                    const isSelected = selectedAttributes.has(label);
                    const w = wedgeGroup.append("path")
                        .attr("d", wedgePath(startAngle, endAngle, 0, radius))
                        .attr("fill", getWedgeColor(label, val))
                        .style("cursor", "pointer")
                        .on("click", (ev) => {
                            ev.stopPropagation();
                            toggleAttribute(label);
                        })
                        .on("mouseenter", function () { d3.select(this).classed("wedge-hover", true); })
                        .on("mouseleave", function () { d3.select(this).classed("wedge-hover", false); });
                    if (isSelected) {
                        w.classed("wedge-selected", true)
                            .attr("stroke", attrColorMap[label] || "#333")
                            .attr("stroke-width", 2.5);
                    }
                });
            }

            function drawAxes() {
                svg.selectAll(".axis").remove();
                svg.selectAll(".label").remove();
                labels.forEach((label, i) => {
                    const a = angleForIndex(i);
                    svg.append("line").attr("class", "axis").attr("x1", 0).attr("y1", 0).attr("x2", Math.cos(a) * radius).attr("y2", Math.sin(a) * radius);
                    svg.append("text").attr("class", "label").attr("x", Math.cos(a) * (radius + 20)).attr("y", Math.sin(a) * (radius + 20)).text(label);
                });
            }
            drawAxes();

            const refPoly = svg.append("path").attr("class", "reference");
            const curPoly = svg.append("path").attr("class", "current");
            const previewPoly = svg.append("path").attr("class", "preview");
            const monthlyPoly = svg.append("path").attr("class", "monthly");
            const handleGroup = svg.append("g");

            function updateHandlePositions() {
                handleGroup.selectAll("circle")
                    .attr("cx", d => posOnSpoke(d.angle, values[d.label])[0])
                    .attr("cy", d => posOnSpoke(d.angle, values[d.label])[1]);
            }

            let handles = handleGroup.selectAll("circle")
                .data(labels.map((label, i) => ({ label, angle: angleForIndex(i) })))
                .join("circle")
                .attr("class", "handle")
                .attr("r", 6)
                .attr("cx", d => posOnSpoke(d.angle, values[d.label])[0])
                .attr("cy", d => posOnSpoke(d.angle, values[d.label])[1])
                .call(d3.drag().on("drag", function (ev, d) {
                    const r = Math.min(radius, Math.hypot(ev.x, ev.y));
                    let val = Math.round(r / step);
                    val = Math.max(1, Math.min(5, val));
                    values[d.label] = val;
                    d3.select(this).attr("cx", posOnSpoke(d.angle, val)[0]).attr("cy", posOnSpoke(d.angle, val)[1]);
                    drawPolygons();
                    drawMonthlyAverage(); // keep monthly visible while editing
                }));

            function polygonForVals(valMap) { return labels.map((lbl, i) => posOnSpoke(angleForIndex(i), valMap[lbl])); }

            function drawPolygons() {
                drawWedges(); // Update wedge background colors
                const ptsCur = polygonForVals(values);
                curPoly.attr("d", d3.line().curve(d3.curveLinearClosed)(ptsCur));
                const ref = getMostRecentEntry();
                if (ref) {
                    const ptsRef = polygonForVals(ref);
                    refPoly.attr("d", d3.line().curve(d3.curveLinearClosed)(ptsRef));
                } else { refPoly.attr("d", null); }
            }

            function drawPreview(valMapOrNull) {
                if (!valMapOrNull) { previewPoly.attr("d", null); return; }
                const pts = polygonForVals(valMapOrNull);
                previewPoly.attr("d", d3.line().curve(d3.curveLinearClosed)(pts));
            }

            function computeMonthlyAverage() {
                const sinceISO = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
                const q = `SELECT ${ITEMS.map(n => `"${n}"`).join(",")} FROM entries WHERE ts>='${sinceISO}'`;
                const res = db.exec(q);
                if (!res.length) return null;
                const rows = res[0].values;
                const sums = Object.fromEntries(ITEMS.map(n => [n, 0]));
                rows.forEach(r => { ITEMS.forEach((n, i) => { sums[n] += (r[i] ?? 3); }); });
                const cnt = rows.length;
                const avg = {}; ITEMS.forEach(n => avg[n] = sums[n] / cnt);
                return { avg, count: cnt };
            }

            function drawMonthlyAverage() {
                const m = computeMonthlyAverage();
                if (!m) { monthlyPoly.attr("d", null); status("No entries in last 30 days."); return; }
                const pts = polygonForVals(m.avg);
                monthlyPoly.attr("d", d3.line().curve(d3.curveLinearClosed)(pts));
                status(`30-day average (${m.count} ${m.count === 1 ? "entry" : "entries"})`);
            }

            // Initial draw
            drawPolygons();
            drawMonthlyAverage();

            // Randomize layout (keep values)
            document.getElementById("randomize").onclick = () => {
                labels = d3.shuffle(labels.slice());
                handles = handleGroup.selectAll("circle")
                    .data(labels.map((label, i) => ({ label, angle: angleForIndex(i) })))
                    .join("circle")
                    .attr("class", "handle")
                    .attr("r", 6)
                    .attr("cx", d => posOnSpoke(d.angle, values[d.label])[0])
                    .attr("cy", d => posOnSpoke(d.angle, values[d.label])[1])
                    .call(d3.drag().on("drag", function (ev, d) {
                        const r = Math.min(radius, Math.hypot(ev.x, ev.y));
                        let val = Math.round(r / step);
                        val = Math.max(1, Math.min(5, val));
                        values[d.label] = val;
                        d3.select(this).attr("cx", posOnSpoke(d.angle, val)[0]).attr("cy", posOnSpoke(d.angle, val)[1]);
                        drawPolygons();
                        drawMonthlyAverage();
                    }));
                drawAxes();
                drawPolygons();
                drawPreview(null);
                drawMonthlyAverage();
                status("Petals randomized (values preserved).");
            };

            // Save sleep independently
            document.getElementById("save-sleep").onclick = () => {
                const sleepEl = document.getElementById("hours-slept");
                const val = sleepEl.value ? parseFloat(sleepEl.value) : null;
                if (!val || val <= 0) { status("Enter a valid sleep value."); return; }
                const ts = new Date().toISOString();
                const stmt = db.prepare('INSERT INTO sleep_log (ts, hours_slept) VALUES (?,?)');
                stmt.run([ts, val]); stmt.free(); persist();
                sleepEl.value = "";
                status(`Logged ${val}h sleep.`);
                updateLastEntryDate();
            };

            // Save
            document.getElementById("save").onclick = async () => {
                const missing = ITEMS.filter(k => !(values[k] >= 1 && values[k] <= 5));
                if (missing.length) { status("Please rate all 20 items (1–5)."); return; }

                const ts = new Date().toISOString();
                const log = document.getElementById("log").value.trim();
                const sleepEl = document.getElementById("hours-slept");
                const hourSlept = sleepEl.value ? parseFloat(sleepEl.value) : null;
                const getByIndex = i1 => values[ITEMS[i1 - 1]];
                const posScore = POS_IDX.reduce((s, i) => s + getByIndex(i), 0);
                const negScore = NEG_IDX.reduce((s, i) => s + getByIndex(i), 0);

                const cols = ["ts", "log", ...ITEMS, "positive_score", "negative_score", "hours_slept"];
                const q = `INSERT INTO entries (${cols.map(c => '"' + c + '"').join(",")}) VALUES (${cols.map(() => "?").join(",")})`;
                const vals = [ts, log, ...ITEMS.map(k => values[k]), posScore, negScore, hourSlept];
                const stmt = db.prepare(q); stmt.run(vals); stmt.free(); persist();

                const latest = getMostRecentEntry();
                ITEMS.forEach(k => values[k] = (latest && latest[k] != null) ? latest[k] : 3);
                updateHandlePositions();
                drawPolygons();
                drawPreview(null);
                drawTimeSeries();
                drawMonthlyAverage();

                downloadDB();
                status("Saved & downloaded database.");
                document.getElementById("log").value = "";
                document.getElementById("hours-slept").value = "";
                updateLastEntryDate();
            };

            // Clear
            document.getElementById("clear").onclick = () => {
                if (!confirm("Delete all saved entries?")) return;
                db.exec("DELETE FROM entries"); persist();
                ITEMS.forEach(k => values[k] = 3);
                updateHandlePositions();
                drawPolygons(); drawPreview(null); drawTimeSeries();
                monthlyPoly.attr("d", null);
                status("Database cleared.");
            };

            // ===== Copy JSON =====
            function getAllEntries() {
                const res = db.exec(`SELECT id, ts, log, positive_score, negative_score, ${ITEMS.map(n => `"${n}"`).join(",")} FROM entries ORDER BY ts ASC`);
                if (!res.length) return [];
                const rows = res[0].values;
                return rows.map(r => {
                    const obj = { id: r[0], ts: r[1], log: r[2] || "", positive_score: r[3], negative_score: r[4], items: {} };
                    ITEMS.forEach((name, idx) => obj.items[name] = r[5 + idx]);
                    return obj;
                });
            }

            async function copyJSON() {
                const data = getAllEntries();
                const text = JSON.stringify(data, null, 2);
                if (!data.length) { status("No entries to copy."); return; }
                try {
                    await navigator.clipboard.writeText(text);
                    status(`Copied ${data.length} ${data.length === 1 ? "entry" : "entries"} to clipboard as JSON.`);
                } catch (e) {
                    // Fallback: try execCommand, then download
                    try {
                        const ta = document.createElement("textarea");
                        ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand("copy"); document.body.removeChild(ta);
                        status(`Copied ${data.length} ${data.length === 1 ? "entry" : "entries"} to clipboard as JSON.`);
                    } catch (err) {
                        const blob = new Blob([text], { type: "application/json" });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a"); a.href = url; a.download = "panas.json"; a.click(); URL.revokeObjectURL(url);
                        status("Clipboard blocked. Downloaded panas.json instead.");
                    }
                }
            }

            document.getElementById("copyJson").onclick = copyJSON;

            // Timeseries
            const tsvg = d3.select("#timeseries").attr("viewBox", [0, 0, 760, 310]);
            const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

            function drawTimeSeries() {
                if (selectedAttributes.size > 0) {
                    drawAttributeTimeSeries();
                    return;
                }
                drawBalanceTimeSeries();
            }

            function drawAttributeTimeSeries() {
                tsvg.selectAll("*").remove();
                const res = db.exec(`SELECT ts, log, ${ITEMS.map(n => `"${n}"`).join(",")} FROM entries ORDER BY ts ASC`);
                if (!res.length) return;
                const rows = res[0].values.map(r => {
                    const itemVals = {}; ITEMS.forEach((name, idx) => itemVals[name] = r[2 + idx]);
                    return { ts: new Date(r[0]), log: r[1] || "", itemVals };
                });

                const attrs = Array.from(selectedAttributes);
                const posAttrs = attrs.filter(a => POS_ITEMS.has(a));
                const negAttrs = attrs.filter(a => NEG_ITEMS.has(a));

                // Build diverging stacked data: positive stacks upward, negative stacks downward (raw values)
                const stackedRows = rows.map(r => {
                    let posSum = 0, negSum = 0;
                    const layers = {};
                    posAttrs.forEach(attr => {
                        const val = r.itemVals[attr] || 0;
                        layers[attr] = { y0: posSum, y1: posSum + val };
                        posSum += val;
                    });
                    negAttrs.forEach(attr => {
                        const val = r.itemVals[attr] || 0;
                        layers[attr] = { y0: -negSum, y1: -(negSum + val) };
                        negSum += val;
                    });
                    return { ts: r.ts, log: r.log, itemVals: r.itemVals, layers, posTotal: posSum, negTotal: negSum };
                });

                const maxPos = d3.max(stackedRows, d => d.posTotal) || 5;
                const maxNeg = d3.max(stackedRows, d => d.negTotal) || 5;
                const yMax = Math.max(maxPos, maxNeg, 5);

                const margin = { l: 50, r: 20, t: 10, b: 50 };
                const W = 760, H = 310, iw = W - margin.l - margin.r, ih = H - margin.t - margin.b;
                const g = tsvg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);
                const x = d3.scaleTime().domain(d3.extent(rows, d => d.ts)).range([0, iw]);

                const hasPos = posAttrs.length > 0, hasNeg = negAttrs.length > 0;
                const yMin = hasNeg ? -yMax : 0;
                const yMaxVal = hasPos ? yMax : 0;
                const y = d3.scaleLinear().domain([yMin, yMaxVal]).nice().range([ih, 0]);

                // X-axis at y=0
                g.append("g").attr("transform", `translate(0,${y(0)})`).call(d3.axisBottom(x));
                g.append("g").call(d3.axisLeft(y));

                // Zero line
                if (hasPos && hasNeg) {
                    g.append("line").attr("x1", 0).attr("x2", iw)
                        .attr("y1", y(0)).attr("y2", y(0))
                        .attr("stroke", "#999").attr("stroke-width", 0.8);
                }

                // Draw positive stacked areas (upward from 0)
                posAttrs.forEach(attr => {
                    const color = attrColorMap[attr] || "#999";
                    const area = d3.area()
                        .x(d => x(d.ts))
                        .y0(d => y(d.layers[attr].y0))
                        .y1(d => y(d.layers[attr].y1))
                        .curve(d3.curveMonotoneX);
                    g.append("path").datum(stackedRows)
                        .attr("fill", color).attr("fill-opacity", 0.55)
                        .attr("stroke", color).attr("stroke-width", 1.2)
                        .attr("d", area);
                });

                // Draw negative stacked areas (downward from 0)
                negAttrs.forEach(attr => {
                    const color = attrColorMap[attr] || "#999";
                    const area = d3.area()
                        .x(d => x(d.ts))
                        .y0(d => y(d.layers[attr].y0))
                        .y1(d => y(d.layers[attr].y1))
                        .curve(d3.curveMonotoneX);
                    g.append("path").datum(stackedRows)
                        .attr("fill", color).attr("fill-opacity", 0.55)
                        .attr("stroke", color).attr("stroke-width", 1.2)
                        .attr("d", area);
                });

                // Tooltip helper
                function tipHtml(d) {
                    const parts = [`<b>${d.ts.toLocaleString()}</b>`];
                    if (posAttrs.length) {
                        parts.push(`<span style="opacity:.6;font-size:.85em">▲ positive</span>`);
                        posAttrs.forEach(a => {
                            parts.push(`<span style="color:${attrColorMap[a] || '#666'}">&#9632; ${a}: ${d.itemVals[a]}</span>`);
                        });
                    }
                    if (negAttrs.length) {
                        parts.push(`<span style="opacity:.6;font-size:.85em">▼ negative</span>`);
                        negAttrs.forEach(a => {
                            parts.push(`<span style="color:${attrColorMap[a] || '#666'}">&#9632; ${a}: ${d.itemVals[a]}</span>`);
                        });
                    }
                    if (d.log) parts.push(`<div style="margin-top:4px;opacity:.9">${d.log.replace(/</g, "&lt;")}</div>`);
                    return parts.join("<br>");
                }

                // Invisible hover zones (full height)
                const bandW = rows.length > 1 ? Math.max(4, iw / rows.length) : iw;
                g.selectAll(".hover-zone").data(stackedRows).enter().append("rect")
                    .attr("class", "hover-zone")
                    .attr("x", d => x(d.ts) - bandW / 2).attr("y", 0)
                    .attr("width", bandW).attr("height", ih)
                    .attr("fill", "transparent").attr("cursor", "crosshair")
                    .on("mouseover", (ev, d) => {
                        tooltip.style("opacity", 1).html(tipHtml(d))
                            .style("left", (ev.pageX + 10) + "px").style("top", (ev.pageY - 28) + "px");
                        drawPreview(d.itemVals);
                        monthlyPoly.attr("d", null);
                        status(`Previewing ${d.ts.toLocaleString()} on windrose`);
                    })
                    .on("mousemove", (ev, d) => {
                        tooltip.style("opacity", 1).html(tipHtml(d))
                            .style("left", (ev.pageX + 10) + "px").style("top", (ev.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.style("opacity", 0);
                        drawPreview(null);
                        drawMonthlyAverage();
                    });

                g.append("text").attr("x", iw / 2).attr("y", ih + 38).attr("text-anchor", "middle").text("Date");
                g.append("text").attr("x", -ih / 2).attr("y", -38).attr("text-anchor", "middle").attr("transform", "rotate(-90)").text("Score");
            }

            function drawBalanceTimeSeries() {
                tsvg.selectAll("*").remove();
                const res = db.exec(`SELECT ts, positive_score, negative_score, log, ${ITEMS.map(n => `"${n}"`).join(",")} FROM entries ORDER BY ts ASC`);
                if (!res.length) return;
                const rows = res[0].values.map(r => {
                    const itemVals = {}; ITEMS.forEach((name, idx) => itemVals[name] = r[4 + idx]);
                    const pos = r[1], neg = r[2];
                    const total = pos + neg; // total intensity (20-100 range, since each is 10-50)
                    // Log ratio: log(pos/neg), symmetric around 0 when equal
                    // Range is roughly -1.6 to +1.6 (log(10/50) to log(50/10))
                    const logRatio = Math.log(pos / neg);
                    return { ts: new Date(r[0]), pos, neg, diff: pos - neg, total, logRatio, log: r[3] || "", itemVals };
                });

                // Calculate saturation scale based on YOUR actual score range
                // Full 0→1 saturation range mapped to your data's min→max
                const totalMin = d3.min(rows, d => d.total);
                const totalMax = d3.max(rows, d => d.total);
                const satScale = d3.scaleLinear().domain([totalMin, totalMax]).range([0, 1]).clamp(true);

                // Map log ratio to 0-1 for color interpolation
                // Use YOUR actual data range so the most extreme entry gets full color
                const absLogRatioMax = d3.max(rows, d => Math.abs(d.logRatio));
                const logRatioScale = d3.scaleLinear().domain([-absLogRatioMax, absLogRatioMax]).range([0, 1]).clamp(true);

                // Color function: log ratio determines color (yellow for positive, purple for negative)
                // We interpolate in RGB space
                function getColor(d) {
                    // logRatio: negative = more negative affect, 0 = equal, positive = more positive affect
                    const sat = satScale(d.total);
                    // Purple for negative, yellow for positive
                    const purple = d3.rgb(120, 50, 160);  // deep purple
                    const yellow = d3.rgb(255, 220, 40);  // bright yellow

                    // Map log ratio to 0-1 range for interpolation
                    const colorT = logRatioScale(d.logRatio);
                    const baseColor = d3.interpolateRgb(purple, yellow)(colorT);

                    // Apply saturation: interpolate between gray and the base color
                    const gray = d3.rgb(160, 160, 160);
                    return d3.interpolateRgb(gray, baseColor)(sat);
                }

                const margin = { l: 70, r: 20, t: 10, b: 50 };
                const W = 760, H = 310, iw = W - margin.l - margin.r, ih = H - margin.t - margin.b;
                const g = tsvg.append("g").attr("transform", `translate(${margin.l},${margin.t})`);
                const x = d3.scaleTime().domain(d3.extent(rows, d => d.ts)).range([0, iw]);
                const y = d3.scaleLinear().domain([-40, 40]).range([ih, 0]); // centered for difference

                g.append("g").attr("transform", `translate(0,${ih})`).call(d3.axisBottom(x));
                g.append("g").call(d3.axisLeft(y));

                // Add zero line for reference
                const y0 = y(0);
                g.append("line").attr("x1", 0).attr("x2", iw).attr("y1", y0).attr("y2", y0)
                    .attr("stroke", "#999").attr("stroke-dasharray", "4,4").attr("opacity", 0.7);

                // Draw filled bars from zero to each point
                const barWidth = Math.max(2, Math.min(20, iw / rows.length * 0.7));
                g.selectAll(".bar").data(rows).enter().append("rect").attr("class", "bar")
                    .attr("x", d => x(d.ts) - barWidth / 2)
                    .attr("y", d => d.diff >= 0 ? y(d.diff) : y0)
                    .attr("width", barWidth)
                    .attr("height", d => Math.abs(y(d.diff) - y0))
                    .attr("fill", d => getColor(d))
                    .attr("opacity", 0.7);

                // Draw line connecting points
                const lineDiff = d3.line().x(d => x(d.ts)).y(d => y(d.diff));
                g.append("path").datum(rows).attr("fill", "none").attr("stroke", "#333").attr("stroke-width", 1.5).attr("d", lineDiff);

                const showTip = (ev, d) => {
                    tooltip.style("opacity", 1)
                        .html(`<b>${d.ts.toLocaleString()}</b><br>Balance: ${d.diff} (Pos: ${d.pos}, Neg: ${d.neg})<br>Log ratio: ${d.logRatio.toFixed(2)}${d.log ? `<div style="margin-top:4px;opacity:.9">${d.log.replace(/</g, "&lt;")}</div>` : ""}`)
                        .style("left", (ev.pageX + 10) + "px").style("top", (ev.pageY - 28) + "px");
                };
                const hideTip = () => tooltip.style("opacity", 0);

                function onOver(ev, d) {
                    showTip(ev, d);
                    drawMonthlyAverage();    // ensure monthly is drawn once (for status), then hide
                    monthlyPoly.attr("d", null);
                    drawPreview(d.itemVals);
                    status(`Previewing ${d.ts.toLocaleString()} on windrose`);
                }
                function onMove(ev, d) { showTip(ev, d); }
                function onOut() {
                    hideTip();
                    drawPreview(null);
                    drawMonthlyAverage();    // restore monthly average on idle
                }

                // Interactive circles on top
                g.selectAll(".pt").data(rows).enter().append("circle").attr("class", "pt")
                    .attr("cx", d => x(d.ts)).attr("cy", d => y(d.diff)).attr("r", 5)
                    .attr("fill", d => getColor(d)).attr("stroke", "#333").attr("stroke-width", 1)
                    .on("mouseover", onOver).on("mousemove", onMove).on("mouseout", onOut);

                g.append("text").attr("x", iw / 2).attr("y", ih + 38).attr("text-anchor", "middle").text("Date");
                g.append("text").attr("x", -ih / 2).attr("y", -48).attr("text-anchor", "middle").attr("transform", "rotate(-90)").text("Balance (−40 to +40)");
            }
            drawTimeSeries();

            function refreshFromDb() {
                const latest = getMostRecentEntry();
                ITEMS.forEach(k => values[k] = (latest && latest[k] != null) ? latest[k] : 3);
                updateHandlePositions();
                drawPolygons();
                drawPreview(null);
                drawTimeSeries();
                drawMonthlyAverage();
                /* Also refresh intent module (may have new rows from cloud merge) */
                if (window.panasRefreshIntent) window.panasRefreshIntent();
            }

            function downloadDB() {
                const dbBlob = new Blob([db.export()], { type: "application/x-sqlite3" });
                const dbUrl = URL.createObjectURL(dbBlob);
                const adb = document.createElement("a");
                adb.href = dbUrl; adb.download = "panas.sqlite"; adb.click();
                URL.revokeObjectURL(dbUrl);
            }

            // Initial alignment
            updateHandlePositions();
            drawPolygons();

            // Show whether last PANAS entry is from today
            function updateLastEntryDate() {
                const el = document.getElementById('last-entry-date');
                if (!el) return;
                // Find most recent timestamp across entries and sleep_log
                let candidates = [];
                try {
                    const r1 = db.exec('SELECT ts FROM entries ORDER BY id DESC LIMIT 1');
                    if (r1.length && r1[0].values.length) candidates.push(new Date(r1[0].values[0][0]));
                } catch (_) { }
                try {
                    const r2 = db.exec('SELECT ts FROM sleep_log ORDER BY id DESC LIMIT 1');
                    if (r2.length && r2[0].values.length) candidates.push(new Date(r2[0].values[0][0]));
                } catch (_) { }
                if (!candidates.length) { el.innerHTML = '<span class="stale">No entries yet</span>'; return; }
                const lastTs = candidates.reduce((a, b) => a > b ? a : b);
                const today = new Date();
                const isToday = lastTs.toDateString() === today.toDateString();
                const label = lastTs.toLocaleDateString() + ' ' + lastTs.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                el.innerHTML = isToday
                    ? '<span class="fresh">✓ Last entry: ' + label + '</span>'
                    : '<span class="stale">⚠ Last entry: ' + label + '</span>';
            }
            updateLastEntryDate();

            // Expose shared state for external modules (js/sync.js, js/intent.js)
            window.panasDB = db;
            window.panasSQL = SQL;
            window.panasPersist = persist;
            window.panasRefreshFromDb = refreshFromDb;
            window.panasGetSleep = function () {
                var el = document.getElementById('hours-slept');
                return el && el.value ? parseFloat(el.value) : null;
            };
            window.dispatchEvent(new CustomEvent('panas-db-ready'));
        })();
    </script>
    <script src="js/sync.js"></script>
    <script src="js/intent.js"></script>

</body>

</html>